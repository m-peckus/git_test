* git cat-file -p <hash>    //log file contents //   //find hash git log//
* git config --add --local  //author info, etc//
*            --unset   //remove value//
*            --remove -section   //remove entire section//
* git switch -c new_branch    //create & switch to new branch//
* git branch    //see you current branch, marked with *//
* git log --decorate =full   //commit history with additional info
*                    =no
*                    =short 
* git config --get init.defaultbranch  //will show default branch configuration


* git log --oneline   //compact commit history
* git log --oneline --graph --all   //full commit & branch history//
* git log --graph
* git log --all
 

* git merge <branch_to_merge>  //no merge commit created//  //must be on the branch into which we are going to merge//
* git commit --amend -m "new commit message""   //amend old commit message with the new message//
* git branch -D <branch_name> //delete selected branch//
* git log --grep=<text_input_from_commit_message>  //will search for matching words inside commit messages//
* git reset --soft <commit-hash>  //will return you back from the current commit to the commit with the hash provided 

DELETE COMMIT FOREVER
* git reset --hard <commit-hash>  //will delete everything that is after that commit.It will be lost/deleted forever


* git checkout <commit-hash> -- file_name.md  //will checkout file from the tree  that is if you want previous version file, unmodified, etc
* git checkout <commit-hash> -- path/to/file_name.md.   //include relative path if file is within the folder
* git ls-tree -r <commit-hash>   //list the files in the commit if you want to confirm that particular file is there
* git rm <file_name>  //Stage the deletion, when you delete a file, you must explicitly tell Git that you want this change (the deletion) to be tracked
* // If you've already deleted the file from your file system, you can just use: git add <file_name>
* // Push the commit to the remote repository: Finally, update the remote repository on GitHub with the changes: git push origin main




* //TO ENABLE REMOTE TRACKING FOR YOUR BRANCH 
 //navigate to the root of your repository using cd path/to/your/repo before running the command.
* Check your current remotes: Use git remote -v to see if your repository is already linked to a remote.
* Add a remote if not present: git remote add origin <remote-repo-URL>
* Push the branch to the remote: git push origin <branch-name>
* Set up tracking: Usually, pushing to a remote with git push will automatically set up tracking.
  If needed, manually configure tracking with: git branch --set-upstream-to=origin/<branch-name> <branch-name>

* // A STEP-BY-STEP APPROACH TO LINK YOUR LOCAL REPOSITORY WITH THE NEW GITHUB REPOSITORY AND START COMMITTING
* //
*  Initialize Git in your local folder (if not already done):
   git init

* Add the GitHub repository as a remote:
  git remote add origin <remote-repo-URL>

* Add and commit your changes:
  git add .
  git commit -m "Initial commit"

* Push your changes to GitHub:
  git push -u origin main   //Substitute main with whatever your main branch is named if itâ€™s different/
 

*// SETTING .GITIGNORE
* create .gitignore file in your repository (location specific -- won't affect folders outside the scope of your current repository)
* add directory name (the one you want to ignore) to .gitignore file (example bookbot/ )
* This tells Git to ignore the entire bookbot directory and all of its contents.

#  If can't push commit messages etc... because:
#  "Updates were rejected because the tip of your current branch is behind
#   Here is how you can resolve this issue:

1. Fetch the latest changes from the remote repository
   git fetch  // This command retrieves the changes from the remote repository but doesn't merge them yet.

2. Merge the fetched changes into your local branch
   git merge origin/main  // Replace main with the name of your branch if it's different.

3. Resolve any merge conflicts
   // If there are conflicts, you'll need to resolve them manually in the files, then stage the resolved files
   git add <file_name>

4. Commit the merge:
  // You might have to commit the merged changes if there were conflicts:
  git commit -m "Resolve merge conflicts"

5. Push the updated branch to the remote repository:
   git push origin main
  //Again, replace main with your actual branch name if needed
  

ADD REMOTE REPOSITORY TO YOUR LOCAL REPOSITORY
* git remote add <new-remote-name> <remote-url>

CHECK YOUR REMOTES 
* git remote -v

PUSH OR PULL FROM A SPECIFIS REMOTE
* git push <remote-name> <branch-name>
* git pull <remote-name> <branch-name>

RENAME THE EXISTING REMOTE
* git remote rename <old-remote-name> <new-remote-name>

CHECK REMOTE EXISTANCE:
To confirm that the repository you want to fetch from exists
* git ls-remote https://github.com/user/repo.git

CHECK COMMIT HISTORY OF A REMOTE REPOSITORY
* git log remote_name/branch_name

SUMMARY:
Use git ls-remote to ensure the repository exists and is accessible.
Add the accessible repository as a remote using git remote add.
Fetch information from the new remote using git fetch.


# CLONE //create remote repo & clone to your computer

1. create repo on Github
2. create empty directory on your computer
3. inside this empty directory run  git clone <url//repo-to-clone>
4. git will create a new folder with the same name as repository you are cloning, inside you will find cloned repository
5. you can now access this repository from your computer, modify/create files and push changes back to remote on Github


